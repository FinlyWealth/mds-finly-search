[
  {
    "objectID": "report/final/capstone_final_report.html",
    "href": "report/final/capstone_final_report.html",
    "title": "Find me a better product!",
    "section": "",
    "text": "FinlyWealth is an affiliate marketing platform that rewards customers for applying for financial products. It is now looking to expand its business by offering e-commerce products through its platform. To support this transition, a team of Master of Data Science students from the University of British Columbia has developed a fast and scalable multimodal search engine that allows users to search using text, images, or both, to find the most relevant products. The final product delivers product discovery by leveraging semantic understanding, enabling more accurate and relevant search results beyond simple keyword matching.\nOur retrieval pipeline combines multimodal CLIP (Radford et al. 2021) embeddings with text-only MiniLM (Face 2024) embeddings, indexing them using FAISS (Johnson, Douze, and Jégou 2017) for efficient large-scale similarity search. At query time, the system identifies semantically relevant products by retrieving similar items from the index and then applies an LLM-based (OpenAI 2023) reranking module to refine the ranking. The architecture consists of a Streamlit (Streamlit Inc. 2019) frontend, a Flask-based (Ronacher 2010) API backend, and a vector database(Kane 2021) that supports embedding-based retrieval. The system effectively handles complex natural language and multimodal queries, a common challenge in e-commerce search. Quantitatively, we observed a Recall@20 of 0.56, Precision@20 of 0.64, and an average query time of 4.24 seconds over a dataset of one million products. Our data product provides a reproducible pipeline that allows FinlyWealth to index new items, evaluate system performance, and support semantic search for future e-commerce offerings."
  },
  {
    "objectID": "report/final/capstone_final_report.html#executive-summary",
    "href": "report/final/capstone_final_report.html#executive-summary",
    "title": "Find me a better product!",
    "section": "",
    "text": "FinlyWealth is an affiliate marketing platform that rewards customers for applying for financial products. It is now looking to expand its business by offering e-commerce products through its platform. To support this transition, a team of Master of Data Science students from the University of British Columbia has developed a fast and scalable multimodal search engine that allows users to search using text, images, or both, to find the most relevant products. The final product delivers product discovery by leveraging semantic understanding, enabling more accurate and relevant search results beyond simple keyword matching.\nOur retrieval pipeline combines multimodal CLIP (Radford et al. 2021) embeddings with text-only MiniLM (Face 2024) embeddings, indexing them using FAISS (Johnson, Douze, and Jégou 2017) for efficient large-scale similarity search. At query time, the system identifies semantically relevant products by retrieving similar items from the index and then applies an LLM-based (OpenAI 2023) reranking module to refine the ranking. The architecture consists of a Streamlit (Streamlit Inc. 2019) frontend, a Flask-based (Ronacher 2010) API backend, and a vector database(Kane 2021) that supports embedding-based retrieval. The system effectively handles complex natural language and multimodal queries, a common challenge in e-commerce search. Quantitatively, we observed a Recall@20 of 0.56, Precision@20 of 0.64, and an average query time of 4.24 seconds over a dataset of one million products. Our data product provides a reproducible pipeline that allows FinlyWealth to index new items, evaluate system performance, and support semantic search for future e-commerce offerings."
  },
  {
    "objectID": "report/final/capstone_final_report.html#introduction",
    "href": "report/final/capstone_final_report.html#introduction",
    "title": "Find me a better product!",
    "section": "1 Introduction",
    "text": "1 Introduction\nAs FinlyWealth expands its offerings from personal finance into the e-commerce sector, it faces the challenge of delivering a scalable and effective product search experience across a rapidly growing and diverse catalog. To address this, a team of Master of Data Science students at the University of British Columbia is developing a machine learning-powered multimodal search engine that understands the semantic meaning of user queries, handling both text and image inputs to help users find relevant products more intuitively and efficiently.\nSearch in the e-commerce domain presents unique challenges due to the wide variety of ways users express their search intent. Traditional approaches, such as TF-IDF-based text search, work well for simple queries like “iPhone” or “laptop.” However, most user queries are free-form, complex, and infrequent. The existing system relies on basic keyword matching, lacks semantic understanding, struggles with spelling mistakes, and does not support multimodal inputs or large-scale performance evaluation.\n\n1.1 Objective\nTo address these gaps, this project designed and implemented a fast, scalable multimodal search system that captures semantic meaning of user queries and returns the most relevant products to the users. Architecture components include:\n\n\n\nTable 1: Summary of Client Requirements and Our Solutions\n\n\n\n\n\n\n\n\n\nClient Requirement\nOur Solution\n\n\n\n\nSupport for natural language and multimodal queries\nCombined CLIP (image-text) and MiniLM (text-only) embeddings; LLM-based reranking for semantic relevance\n\n\nFast response time\nIndexed embeddings using FAISS for efficient approximate nearest neighbor search\n\n\nReusable API endpoints\nDeveloped modular backend with Flask APIs\n\n\nReproducible data pipeline\nDesigned modular indexing, query search, and evaluation pipelines, automated via make\n\n\nWeb interface for user interaction\nBuilt a user-friendly interface using Streamlit\n\n\nTransparent evaluation and benchmarking\nProposed evaluation plan: Recall@20, Precision@20 (human-judged), and query time\n\n\n\n\n\n\nTo support scalable data storage, we use PostgreSQL with the pgvector extension, providing an affordable and efficient solution for storing embeddings and associated metadata.\nThe final data product is evaluated using the following evaluation metrics:\n\nRecall@K: Measures how often the intended or relevant product appears in the top K retrieved results\nPrecision@K: Measures how many of the top K retrieved products are actually relevant, based on manual human relevance assessments\nQuery time: Measures how long each query takes to return results (target &lt;= 5 seconds)"
  },
  {
    "objectID": "report/final/capstone_final_report.html#data-science-methods",
    "href": "report/final/capstone_final_report.html#data-science-methods",
    "title": "Find me a better product!",
    "section": "2 Data Science Methods",
    "text": "2 Data Science Methods\n\n2.1 Data Source, Description and Cleaning\nThe dataset consists of multimodal product data, including images (14,684,588 JPEG files, approximately 67 GB), textual information (product names and descriptions), and structured metadata (e.g., Category, Brand, Color). The metadata is stored in a 12 GB CSV file containing 15,384,100 rows and 30 columns.\nAfter conducting exploratory data analysis and consulting with our partner, we selected the 16 most relevant columns that capture the key information users care about. We excluded non-English market entries—retaining approximately 70% of the dataset—in line with our partner’s business focus. Additionally, we merged the Brand and Manufacturer columns into a single MergedBrand field to reduce duplication while preserving distinct brand information. We chose to ignore missing values in the metadata columns, as these fields are likely to provide supplementary information, while the product name already contains the primary details (Table 2).\n\n\n\nTable 2: Summary of Retained Columns and Their Characteristics\n\n\n\n\n\n\n\n\n\n\nGroup\nAttribute\nDescription / Examples\n\n\n\n\nIdentifiers\nPid\nUnique product ID; links to image filenames\n\n\nText Fields\nName\nProduct title (0.2% missing)\n\n\n\nDescription\nProduct description (0.03% missing)\n\n\n\nCategory\nProduct category (28% missing; ~15 K unique values)\n\n\nPricing & Availability\nPrice\nListed price\n\n\n\n\"PriceCurrency\"\nCurrency of the price\n\n\n\nFinalPrice\nFinal price after discounts\n\n\n\nDiscount\nDiscount percentage or value\n\n\n\nisOnSale\nBoolean flag\n\n\n\nIsInStock\nBoolean flag\n\n\nBranding\nBrand\nBrand name (53% missing; ~21 K unique values)\n\n\n\nManufacturer\nManufacturer name (34% missing; ~26 K unique values)\n\n\nProduct Features\nColor\nProduct color (49% missing; ~170 K unique values)\n\n\n\nGender\nTarget gender (54% missing; 3 values: e.g., male/female)\n\n\n\nSize\nProduct size (46% missing; ~55 K unique values)\n\n\n\nCondition\nProduct condition (e.g., new, used; 5 values)\n\n\n\n\n\n\nGiven the timeline for this project, we’ve selected 1M dataset out of the 15M to build the final data product.\n\n\n\n2.2 Indexing Pipeline\nOur goal was to develop a multimodal search engine capable of delivering relevant product results for a wide range of customer queries. To support this, we designed a system that encodes product data with both text and image understanding and enables scalable retrieval of similar items. The system incorporates TF-IDF for keyword-based matching, CLIP for aligning visual and textual information, MiniLM for efficient semantic text encoding, and FAISS for scalable vector similarity search. This pipeline (Figure 1) is then used to convert the 1M product data into indices that can be searched.\n\n\n\n\n\n\nFigure 1: Indexing Product Data\n\n\n\n\n2.2.1 Cleanind Data\nThe dataset was filtered to include only products priced in USD, CAD, or GBP, ensuring that associated metadata—such as product descriptions—is predominantly in English. Additionally, the Brand and Manufacturer fields, which contained largely redundant information, were consolidated into a single column to reduce duplication and improve consistency.\n\n\n2.2.2 Generating Embeddings\nOur embedding strategy was inspired by Liu and Lopez Ramos (Liu and Lopez Ramos 2025), who combined CLIP and a BERT model fine-tuned on e-commerce data to enhance product search relevance. Since we lacked access to labeled, domain-specific data for fine-tuning, we opted for MiniLM (Face 2024)—a smaller, faster transformer model that performs well out-of-the-box and provides solid semantic understanding. We generate embeddings using both CLIP (for image-text alignment) and MiniLM (for textual metadata), then concatenate them into a single unified embedding, which is stored in a vector database for retrieval.\n\n\n2.2.3 Clustering Generated Embeddings\nTo support scalable and efficient retrieval, we leveraged FAISS, a library optimized for fast similarity search and clustering of dense vectors. We tuned key hyperparameters to determine the optimal number of clusters (nlist) and the number of clusters to probe during search (nprobe). We selected 10,000 clusters, as it provided similar best performance as shown in Figure 2. During retrieval, we search across the top 32 clusters, striking a balance between speed and recall. Using an Inverted File Index (IVF), we clustered 1 million products into 10,000 groups, with each product assigned to its nearest centroid. At query time, FAISS limits the search to the most relevant clusters, significantly improving search efficiency over exhaustive approaches.\n\n\n\n\n\n\nFigure 2: Hyperparameter Seach for FAISS Cluster Size\n\n\n\n\n\n2.2.4 Processing Metadata Text\nIn addition to vector-based methods, we implemented a traditional keyword-based search using TF-IDF, which ranks products based on the relevance to the query. Product descriptions and attributes are processed into tsvector format and stored in a PostgreSQL database. A tsvector is a specialized data type for full-text search in Postgres that tokenizes text into lexemes (root word forms) and removes stopwords, enabling fast and accurate query matching through the tsquery syntax (PostgreSQL Global Development Group, n.d.).\n\n\n\n2.3 Search Pipeline\n\n2.3.1 Generating Query Embeddings\nWhen a search query is submitted, we process it in two forms: the raw text and its corresponding embedding. The raw text is used for traditional full-text search, while the embedding is used for vector-based retrieval. Each method returns a ranked list of results, which are then combined using a weighted scoring system. To further enhance relevance, we apply a Large Language Model (LLM) to rerank the top results based on deeper semantic understanding (Figure 3).\n\n\n\n\n\n\nFigure 3: Workflow for a Search Query using Text only or Text & Image\n\n\n\nFor image-only queries, the full text search and LLM reranking step is skipped since there are no text inputs to use (Figure 4).\n\n\n\n\n\n\nFigure 4: Workflow for a Search Query using Image only\n\n\n\n\n\n2.3.2 Reranking with a Large Language Model (LLM)\nThe LLM plays a key role in improving result relevance by reranking the initial set of retrieved products. It helps interpret the user’s intent and refines the rankings based on multiple criteria, including:\n\nSemantic similarity to the query intent\nDirect keyword matches\nMentions of specific brand names\nPrice relevance compared to similar items\n\nReranking is particularly important because embedding retrieval could return items that are broadly relevant but lack fine-grained alignment with the user’s actual intent. LLMs offer a more nuanced understanding of both the query and the retrieved content, enabling more accurate prioritization of results. This is particularly useful for natural language queries, where the user’s intent may be complex or not explicitly stated.\nFor example, if a user searches for “a cheap office chair for home use,” the user has not explicitly specified a price point and the initial results may include a mix of premium and budget options. An LLM can interpret “cheap” as a key signal and evaluate product prices within the context of similar items. It can lower the ranking of high-end chairs and highlight budget-friendly options that better reflect the user’s intent, which embedding retrieval might not account for.\n\n\n\n2.4 Evaluation\nThis project focused on improving search performance for natural language queries, where traditional keyword-based methods often fail. We compared three configurations: Text Search (baseline), Text + Embeddings, and Text + Embeddings + LLM. The three configurations were evaluated on Recall@20, Precision@20, and Search Time. A summary of evaluation results is provided in Table 3.\n\n\n\n\nTable 3: Evaluation Summary\n\n\n\n\n\n\n\n\n\n\nMethod\nQuery Type\nRecall@20\nPrecision@20\nSearch Time (s)\n\n\n\n\n0\nText Search\nBasic Query\n0.42\n0.73\n0.30\n\n\n1\nText + Embeddings\nBasic Query\n0.33\n0.81\n0.60\n\n\n2\nText + Embeddings + LLM\nBasic Query\n0.41\n0.78\n4.24\n\n\n3\nText Search\nNatural Query\n0.07\n0.07\n0.30\n\n\n4\nText + Embeddings\nNatural Query\n0.53\n0.70\n0.60\n\n\n5\nText + Embeddings + LLM\nNatural Query\n0.58\n0.62\n4.24\n\n\n\n\n\n\n\n\n\n\n\n2.4.1 Recall\nRecall@20 is calculated based on whether the specific target product being searched for appears within the top 20 retrieved results. This evaluation reflects whether the system is able to surface the exact intended product, which is particularly important for e-commerce use cases where users often look for a specific item.\nRecall saw the most improvement for natural queries, the primary focus of this project. The baseline Text Search method retrieved only 7% of relevant results, underscoring its limitations for conversational input. By adding semantic embeddings and LLM reranking, recall was increased to 58%. This highlights the LLM’s ability to recover more relevant items beyond those matched by keywords or nearest-neighbor search.\n\n\n2.4.2 Precision\nPrecision@20 measures the proportion of the top 20 results that are relevant to the query, based on human judgment. It reflects the ranking quality—how many of the returned products are actually useful to the user.\nPrecision also improved substantially for natural queries, rising from 7% with baseline Text Search to 70% with Text + Embeddings, and 62% with the LLM-enhanced pipeline. The slight drop in precision with the LLM is likely due to the subjective nature of our evaluation process. In the absence of labeled ground truth, relevance was manually assessed by team members using their own judgment. Without standardized annotation guidelines, this introduces variability in what is considered “relevant”.\n\n\n2.4.3 Search Time\nSearch time captures the total time taken to process a query and return results. It helps evaluate the responsiveness of the system under different configurations.\nSearch time increased as more complex processing was introduced. The LLM-based reranking step added significant overhead, bringing total query time to 4.24 seconds. This additional time is due entirely to the reranking process, where the LLM semantically evaluates and reorders the top results. Overall, we are still under the target time of 5 seconds."
  },
  {
    "objectID": "report/final/capstone_final_report.html#data-product-and-results",
    "href": "report/final/capstone_final_report.html#data-product-and-results",
    "title": "Find me a better product!",
    "section": "3 Data Product and Results",
    "text": "3 Data Product and Results\nThe data product is comprised of preprocessing scripts, a frontend interface and a backend API.\n\n3.1 Indexing Pipeline\nThe indexing pipeline involves data cleaning, followed by embedding generation, database loading, and finally, FAISS index generation. This process is initiated via the make index command, which executes the aforementioned steps to prepare the products for contextual querying. The pipeline executes its steps in the following sequential order:\n\nclean_data.py: Cleans the raw CSV data by removing null values, filtering for English products etc.\ngenerate_embed.py: Generates embeddings from product names using MiniLM (Wang et al. 2020) and from images using CLIP (Radford et al. 2021), respectively.\nload_db.py: Loads these generated embeddings and associated product metadata into the PGVector database.\ncompute_faiss_index.py : Compute the FAISS indices for faster search.\n\n\n\n3.2 Frontend Interface\nThe Streamlit-based frontend serves as an internal tool for evaluating the quality of search results and testing the underlying API. It supports a range of query types—including text-only, image-only, and multimodal inputs. The interface also provide summary statistics on the retrieved results.\n\n\n\n\n\n\nFigure 5: User Interface\n\n\n\nKey Features:\n\nMultimodal Input: Supports both text queries and image uploads as seen in as [1] in Figure 5\nRich Results Display: Product cards with images, prices, and detailed metadata\nAnalytics Dashboard: Live statistics on search results including price ranges, brand distribution, category breakdowns and LLM reasoning as seen as [2] in Figure 5\nUser Experience Design:\n\nProgressive result loading (20 results initially, expandable)\nVisual feedback for user interactions (Precision). This is the thumbs up and thumbs down button labelled as [4] as seen in Figure 5. These results are collected and are used in calculating precision metrics.\n\n\n\n\n3.3 Backend API\nThe Flask-based (Ronacher 2010) REST API serves as the core processing engine:\nEndpoints:\n\nPOST /api/search: Main search functionality supporting text, image, and multimodal queries\nGET /api/ready: Health check and initialization status\nPOST /api/feedback: User feedback collection for continuous improvement\n\n\nQuery Workflow:\n\n\n\nSearch Workflow\n\n\nOur query workflow starts with passing the search query to the API. This is followed by Embedding Generation, which creates appropriate vector representations. Next, a Hybrid Retrieval step combines both vector similarity and full-text search for comprehensive results. Subsequently, LLM Reranking, utilizing models like OpenAI GPT, optimizes the relevance of the retrieved information. Finally, the top retrieval results are sent back to the frontend.\n\n\n3.4 Database and Storage\nThe system’s data infrastructure is built on Google Cloud. Product metadata and embeddings are stored in a PostgreSQL database with the pgvector extension on Cloud SQL, primarily for retrieval and indexing purposes. Similarity search is performed using FAISS indices, which are stored on Google Cloud Storage alongside product images. This storage setup is highly scalable, making it easy to accommodate growing volumes of product images and embedding indices as the catalog expands.\n\n\n3.5 Strengths and Limitations\nThis section outlines the core strengths and current technical constraints of the search system. While the architecture is designed for flexibility, speed, and multimodal support, certain trade-offs exist due to reliance on pre-trained models and resource requirements.\n\n3.5.1 Key Advantages\n\nMultimodal Capability: Unique ability to process both text and image queries simultaneously\nHybrid Search Architecture: Combines vector similarity with traditional full-text search for improved recall\nScalable Design: FAISS indices enable sub-second search across millions of products\nFlexible Model Integration: Supports multiple embedding models and LLM providers\n\n\n\n3.5.2 Technical Constraints\n\nModel Dependencies: Relies on pre-trained models that may not be domain-specific. No training done\nMemory Requirements: Large embedding matrices require significant RAM and storage for optimal performance\nSingle-Language Support: Currently optimized only for English queries\nUpdate Propagation: Adding new products requires recomputing embeddings and rebuilding indices\n\n\n\n\n3.6 Potential Improvements and Implementation Challenges\nAs the system evolves, several enhancements can be explored to boost retrieval accuracy, scalability, and user relevance. This section highlights key opportunities identified through initial experimentation and outlines the potential benefits of each, along with the practical challenges they present.\n\n3.6.1 Advanced Keyword Extraction with KeyBERT\n\nImprovement: Implement KeyBERT for automatic keyword extraction to enrich text embeddings. This was explored and improved the recall score\nBenefits: Better understanding of product attributes and user intent\nImplementation Challenge: Requires additional compute resources for keyword processing\n\n\n\n3.6.2 Premium Embedding Models\n\nImprovement: Upgrade to OpenAI’s text-embedding-3-large or similar high-performance models\nBenefits: Superior semantic understanding and cross-domain generalization\nImplementation Challenge: Significantly higher API costs and embedding size\n\n\n\n3.6.3 LLM Prompt Engineering with Real Customer Data\n\nImprovement: Develop sophisticated prompts using actual user search patterns and feedback\nBenefits: More contextually aware result reranking\nImplementation Challenge: Privacy concerns and data collection complexity\n\n\n\n3.6.4 Managed Vector Database Migration\n\nImprovement: Transition to Pinecone or similar managed vector database services\nBenefits: Reduced operational overhead, better scalability, advanced features\nImplementation Challenge: Migration complexity and ongoing costs\nCost-Benefit Analysis: Higher operational costs but reduced engineering overhead"
  },
  {
    "objectID": "report/final/capstone_final_report.html#conclusion-and-recommendations",
    "href": "report/final/capstone_final_report.html#conclusion-and-recommendations",
    "title": "Find me a better product!",
    "section": "4 Conclusion and Recommendations",
    "text": "4 Conclusion and Recommendations\nWe have developed a fast and scalable multimodal search engine that allows users to retrieve relevant products using text, image, or hybrid queries. In contrast to Finly’s original platform, which relies on direct keyword matching, our system is built to understand the semantic meaning of natural language and handle complex queries effectively. Even with the most computationally intensive model, the system maintains a response time under 5 seconds, meeting the usability standards for customer-facing applications.\nTo achieve this, we integrated multiple models and tools. For multimodal capability, we leveraged CLIP (Radford et al. 2021) to extract features from both text and images. To capture semantic information, we incorporated MiniLM (Face 2024) along with an LLM-based reranking module (OpenAI 2023). To ensure low latency, we implemented FAISS indexing (Johnson, Douze, and Jégou 2017) for efficient similarity search. Additionally, we adopted Google Cloud for data storage to meet the scalability requirements.\nIn our performance evaluation on a dataset of one million products, the system achieved a Recall@20 of 0.56, Precision@20 of 0.64, and an average search time of 4.24 seconds. These results demonstrate that our search engine is both accurate and responsive.\n\n4.1 Recommendations\nOur product successfully met all of Finly’s requirements. We also developed a web interface that presents a statistical summary of the retrieved results and integrated a modular evaluation framework for our partner. However, several limitations of the current system should be noted.\n\nEvaluation limitations: The precision evaluation was based on the manual annotation of the top 20 retrieved products by our team. Given our limited domain expertise in e-commerce and the subjective interpretation of what constitutes a “relevant” product, the labeling may suffer from inconsistency and potential bias. To improve reliability, we recommend involving an e-commerce expert to standardize annotation guidelines and ensure a more professional and consistent evaluation process.\nScalability and infrastructure: Currently, our reranking module is applied only to the top 30 retrieved products due to its relatively long execution time. We did not conduct experiments to determine the optimal cutoff threshold that balances performance and latency, primarily due to time and resource constraints. However, we believe that implementing an adaptive cutoff strategy could be a valuable direction for future enhancement.\nAdditionally, due to limited computing resources, we generated embeddings for only one million products, rather than the entire product catalog. This limitation can be easily addressed by rerunning our reproducible indexing pipeline once Finly gains access to sufficient computational infrastructure.\nData constraints: Due to the absence of labeled customer interaction data, our current similarity search relies solely on fusion embeddings of text and image inputs, without any model fine-tuning. Prior academic research (Liu and Lopez Ramos 2025) suggests that adding a projection layer on top of the fusion embedding can improve performance. Once Finly acquires sufficient labeled data, the pipeline can be adapted to include such a layer along with an appropriately designed loss function.\n\nDespite the limitations discussed above, our solution offers FinlyWealth a robust, scalable architecture and a reproducible development pipeline. This positions the company well to scale the system further and adapt it to the growing and evolving needs of its e-commerce platform."
  },
  {
    "objectID": "report/final/capstone_final_report.html#appendix",
    "href": "report/final/capstone_final_report.html#appendix",
    "title": "Find me a better product!",
    "section": "Appendix",
    "text": "Appendix\n\nTools and Libraries\n\n\n\nLibrary\nPurpose in Project\n\n\n\n\nNumPy\nEfficient numerical operations, especially for vector manipulation and math ops.\n\n\nFlask\nLightweight web framework used for rapid prototyping of API endpoints.\n\n\nFAISS\nApproximate nearest neighbor search for CLIP embeddings; enables fast vector search.\n\n\nHugging Face\nAccess to pretrained models like CLIP; used for text and image embedding.\n\n\nPillow\nImage processing library used for resizing, normalization, and format conversion.\n\n\nspaCy\nNatural language processing toolkit for tokenization, NER, and text normalization.\n\n\nPinecone\nScalable, cloud-based vector database for fast and persistent similarity search.\n\n\nPostgreSQL\nRelational database to store Embeddings. Allows for multiple columns to have ebeddings\n\n\n\n\n\nDefinitions\nCLIP: Generates embeddings for both text and images, mapping them into a shared embedding space. We are not training any embedding model, instead we use off-the-shelf CLIP models to generate embeddings.\nEmbedding Generation: The preprocessed query is then transformed into a numerical representation (an embedding) that captures its semantic meaning.\nFAISS (Facebook AI Similarity Search) is a library that allows developers to quickly search for embeddings of multimedia documents.Enables efficient approximate nearest neighbor search over embeddings.\nTF-IDF: A numerical statistic used to evaluate the importance of a word in a document within a collection of documents"
  }
]